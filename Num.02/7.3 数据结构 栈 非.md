### 7.3 数据结构 栈

------

栈（Stack）是一种基础的数据结构，遵循后进先出（Last In First Out, LIFO）的原则。栈可以简单地理解为一种限制插入和删除只能在同一端进行的线性表。

#### 1. 栈的基本特点

1. **后进先出（LIFO）**：最后入栈的元素最先出栈，类似于我们把书叠在一起，后放的书先取。
2. **限制操作**：栈的操作通常只允许在栈顶进行，即只能访问最近入栈的元素，而不能访问中间或底部的元素。
3. **基本操作**：栈的基本操作包括入栈（push）和出栈（pop），以及获取栈顶元素但不删除（top/peek）。

#### 2. 栈的实现

栈可以基于数组或链表实现，每种实现方式都有自己的优缺点。

##### 2.1 数组实现栈

使用数组实现栈的主要优点是易于实现和操作，同时具有较好的随机访问性能。但是，数组大小通常是固定的，扩展数组可能需要重新分配内存并复制元素，这可能会导致操作的时间复杂度增加。

##### 2.2 链表实现栈

使用链表实现栈的主要优点是动态分配内存，可以根据需要灵活地增加或删除元素，因此不会受到固定大小的限制。但是，链表实现可能会增加一些额外的指针开销，并且随机访问性能较差。

#### 3. 栈的基本操作

##### 3.1 入栈（push）

将一个元素压入栈顶。

##### 3.2 出栈（pop）

从栈顶移除一个元素，并返回移除的元素。

##### 3.3 获取栈顶元素但不删除（top/peek）

返回栈顶的元素，但不将其从栈中移除。

#### 4. 栈的应用

##### 4.1 函数调用栈

在程序执行时，函数调用过程中的局部变量、参数以及函数返回地址等信息都保存在函数调用栈中。每当调用一个新函数时，都会将其相关信息压入栈顶，当函数执行完毕时，将其信息弹出栈顶。

##### 4.2 表达式求值

栈可以用于表达式求值，特别是中缀表达式转换为后缀表达式（逆波兰表达式）后，利用栈可以方便地进行求值。

##### 4.3 内存分配和回收

栈也用于管理内存的分配和回收。例如，函数调用栈中的局部变量就是通过栈来分配和回收内存的。

##### 4.4 浏览器的后退功能

浏览器的后退功能通常使用栈来实现，每次浏览新页面时，将页面的URL压入栈顶，当用户点击后退按钮时，从栈顶弹出上一个页面的URL。

#### 5. 栈的复杂度分析

假设栈中有 n 个元素，以下是栈的常见操作的时间复杂度：

- 入栈（push）：O(1)
- 出栈（pop）：O(1)
- 获取栈顶元素但不删除（top/peek）：O(1)

#### 6. 一次总结

栈作为一种基础的数据结构，在计算机科学中有着广泛的应用。通过理解栈的基本特点、实现方式和常见应用，可以更好地应对实际编程中的各种问题，提高程序的性能和可读性。

------

好的，让我们更详细地探讨栈的各个方面。

#### 7. 栈的内部结构

##### 7.1 栈的节点

在栈的链式实现中，栈的节点通常包含两部分信息：
- **数据域（Data）**：存储栈中的元素。
- **指针域（Pointer/Next）**：指向下一个节点的指针。

##### 7.2 栈的头指针

栈的链式实现中，通常使用一个头指针来指向栈顶节点。栈的头指针始终指向栈顶元素，方便进行入栈和出栈操作。

#### 8. 栈的基本操作

##### 8.1 入栈（push）

入栈操作将一个新的元素压入栈顶，即在栈顶位置插入一个新节点。入栈操作分为以下几个步骤：
1. 创建一个新的节点，并将要入栈的元素存储在该节点的数据域中。
2. 将新节点的指针域指向当前栈顶节点。
3. 更新栈的头指针，使其指向新节点。

##### 8.2 出栈（pop）

出栈操作将栈顶的元素移出栈，即移除栈顶位置的节点。出栈操作分为以下几个步骤：
1. 将栈顶节点的数据保存下来以备返回。
2. 将头指针指向栈顶节点的下一个节点。
3. 释放原栈顶节点的内存空间。
4. 返回被移出的元素。

##### 8.3 获取栈顶元素但不删除（top/peek）

获取栈顶元素但不删除的操作只需要返回栈顶节点的数据域中的元素即可，不需要修改栈的结构。

#### 9. 栈的实现方式

##### 9.1 链式栈

链式栈使用链表来实现栈的基本操作。链式栈的优点是可以动态地分配内存，不受固定大小的限制，但是需要额外的指针空间。

##### 9.2 数组栈

数组栈使用数组来实现栈的基本操作。数组栈的优点是操作简单高效，不需要额外的指针空间，但是大小固定，可能会导致栈溢出。

#### 10. 栈的应用场景

##### 10.1 函数调用栈

在程序执行过程中，每次函数调用时，函数的局部变量、参数、返回地址等信息都保存在函数调用栈中。当函数调用结束时，这些信息会被依次弹出栈顶，恢复到调用前的状态。

##### 10.2 表达式求值

在表达式求值过程中，栈可以用来存储操作数和操作符，帮助我们实现表达式的计算。

##### 10.3 括号匹配

利用栈的后进先出的特性，可以方便地检查表达式中括号的匹配情况，如圆括号、方括号和花括号等。

##### 10.4 浏览器的后退功能

浏览器的后退功能通常使用栈来实现，每次访问新页面时，将页面的URL压入栈顶，当用户点击后退按钮时，从栈顶弹出上一个页面的URL。

#### 11. 栈的复杂度分析

假设栈中有 n 个元素，以下是栈的常见操作的时间复杂度：

- 入栈（push）：O(1)
- 出栈（pop）：O(1)
- 获取栈顶元素但不删除（top/peek）：O(1)

#### 12. 二次总结

栈作为一种基础的数据结构，在计算机科学中有着广泛的应用。通过深入理解栈的内部结构、基本操作、实现方式和应用场景，可以更好地应对实际编程中的各种问题，提高程序的性能和可读性。

------

#### 13. 代码演示

当然可以！以下是使用链表实现的栈的示例代码：

```cpp
#include <iostream>

// 定义栈节点结构
template <typename T>
struct Node {
    T data;
    Node<T>* next;
    Node(const T& newData) : data(newData), next(nullptr) {}
};

// 定义链式栈类
template <typename T>
class Stack {
private:
    Node<T>* top; // 栈顶指针

public:
    // 构造函数
    Stack() : top(nullptr) {}

    // 析构函数
    ~Stack() {
        clear();
    }

    // 判断栈是否为空
    bool isEmpty() const {
        return top == nullptr;
    }

    // 入栈操作
    void push(const T& item) {
        Node<T>* newNode = new Node<T>(item);
        newNode->next = top;
        top = newNode;
    }

    // 出栈操作
    T pop() {
        if (isEmpty()) {
            std::cerr << "Error: Stack is empty." << std::endl;
            exit(EXIT_FAILURE);
        }
        T data = top->data;
        Node<T>* temp = top;
        top = top->next;
        delete temp;
        return data;
    }

    // 获取栈顶元素但不删除
    T peek() const {
        if (isEmpty()) {
            std::cerr << "Error: Stack is empty." << std::endl;
            exit(EXIT_FAILURE);
        }
        return top->data;
    }

    // 清空栈
    void clear() {
        while (!isEmpty()) {
            pop();
        }
    }
};

int main() {
    Stack<int> stack;

    // 入栈操作
    stack.push(10);
    stack.push(20);
    stack.push(30);

    // 获取栈顶元素并打印
    std::cout << "Top element: " << stack.peek() << std::endl;

    // 出栈操作
    std::cout << "Pop element: " << stack.pop() << std::endl;

    // 再次获取栈顶元素并打印
    std::cout << "Top element: " << stack.peek() << std::endl;

    return 0;
}
```

这段代码演示了如何使用链表实现栈，并包括了栈的基本操作：入栈（push）、出栈（pop）、获取栈顶元素但不删除（peek）以及清空栈（clear）。

------

#### 14. 零散补充

除了基本操作之外，栈还可以有一些其他补充操作和特性：

##### 14.1 栈的大小（Size）

栈的大小指的是栈中元素的个数。可以通过遍历栈的方式计算大小，或者在实现栈的过程中维护一个计数器来记录栈的大小。

##### 14.2 栈的容量（Capacity）

栈的容量指的是栈所能容纳的最大元素个数。对于使用数组实现的栈，通常需要预先指定栈的容量。当栈的实际大小达到容量上限时，可能需要进行扩容操作。

##### 14.3 栈的扩容（Resize）

当栈使用数组实现且容量不足以存储新的元素时，需要进行扩容操作。扩容操作通常涉及重新分配更大的内存空间，并将原有元素复制到新的内存空间中。

##### 14.4 栈的遍历（Traversal）

栈的遍历指的是按照一定顺序访问栈中的所有元素。由于栈的特性是后进先出，因此遍历栈的顺序通常是从栈顶到栈底。

##### 14.5 栈的复制（Copy）

栈的复制操作可以创建一个与原栈内容相同的新栈。复制操作通常涉及遍历原栈，并将每个元素依次入栈到新栈中。

##### 14.6 栈的反转（Reverse）

栈的反转操作可以将栈中的元素顺序颠倒过来。可以通过辅助栈或递归等方式实现栈的反转操作。

##### 14.7 栈的比较（Comparison）

栈的比较操作可以用来比较两个栈是否相等。相等的条件是两个栈具有相同的大小，并且对应位置上的元素相等。

##### 14.8 栈的序列化与反序列化

栈的序列化指的是将栈的内容转换成字符串或字节流的形式，以便于存储或传输。栈的反序列化则是将序列化后的字符串或字节流还原成原始的栈结构。
