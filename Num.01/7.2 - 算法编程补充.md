### 一、时间复杂度和空间复杂度

#### 1. 常见算法的时间复杂度

下面是一些常见算法的时间复杂度，按照从最低到最高的顺序排列：

常数时间复杂度：O(1)
- 无论输入规模如何增大，算法的执行时间都保持恒定。

对数时间复杂度：O(log n)
- 针对每次操作，问题规模都被减小为原来的一半。

线性时间复杂度：O(n)
- 算法的执行时间与输入规模成线性关系。

线性对数时间复杂度：O(n log n)
- 结合了线性和对数复杂度，通常在某些高效排序算法中出现。

平方时间复杂度：O(n^2)
- 算法的执行时间与输入规模的平方成正比，通常在嵌套循环的算法中出现。

立方时间复杂度：O(n^3)
- 算法的执行时间与输入规模的立方成正比，通常在涉及三层嵌套循环的算法中出现。

指数时间复杂度：O(2^n) 或 O(k^n)（k > 1）
- 算法的执行时间随着输入规模的增加呈指数级增长，通常在递归算法中出现。

多项式时间复杂度：O(n^k)
- 算法的执行时间与输入规模的某个固定幂次成正比，其中 k 是常数。

指数时间复杂度：O(2^n) 或 O(k^n)（k > 1）
- 算法的执行时间随着输入规模的增加呈指数级增长，通常在递归算法中出现。

阶乘时间复杂度：O(n!)
- 算法的执行时间与输入规模的阶乘成正比，通常在穷举所有可能情况的算法中出现。

需要注意的是，以上只是算法时间复杂度的一些常见示例，实际应用中还可能涉及到其他更复杂的时间复杂度。此外，时间复杂度并不是唯一考虑的因素，还需要综合考虑空间复杂度、实际问题的特点等因素来选择合适的算法。

------

#### 2. 常见排序算法的时间复杂度

以下是常见的排序算法以及它们的平均、最好和最坏时间复杂度：

1. 冒泡排序（Bubble Sort）
   - 平均时间复杂度：O(n^2)
   - 最好时间复杂度：O(n)
   - 最坏时间复杂度：O(n^2)
   
2. 选择排序（Selection Sort）
   - 平均时间复杂度：O(n^2)
   - 最好时间复杂度：O(n^2)
   - 最坏时间复杂度：O(n^2)
   
3. 插入排序（Insertion Sort）
   - 平均时间复杂度：O(n^2)
   - 最好时间复杂度：O(n)
   - 最坏时间复杂度：O(n^2)
   
4. 快速排序（Quick Sort）
   - 平均时间复杂度：O(n log n)
   - 最好时间复杂度：O(n log n)
   - 最坏时间复杂度：O(n^2) （发生在极端情况下）
   
5. 归并排序（Merge Sort）
   - 平均时间复杂度：O(n log n)
   - 最好时间复杂度：O(n log n)
   - 最坏时间复杂度：O(n log n)
   
6. 堆排序（Heap Sort）
   - 平均时间复杂度：O(n log n)
   - 最好时间复杂度：O(n log n)
   - 最坏时间复杂度：O(n log n)
   
7. 希尔排序（Shell Sort）
   - 平均时间复杂度：取决于步长序列，通常在 O(n log n) 到 O(n^2) 之间。
   - 最好时间复杂度：O(n log n) （某些步长序列）
   - 最坏时间复杂度：O(n^2)
   
8. 计数排序（Counting Sort）
   - 平均时间复杂度：O(n + k)，其中 k 是非负整数的范围
   - 最好时间复杂度：O(n + k)
   - 最坏时间复杂度：O(n + k)
   
9. 桶排序（Bucket Sort）
   - 平均时间复杂度：O(n + k)，其中 k 是桶的数量
   - 最好时间复杂度：O(n^2)（某些情况下）
   - 最坏时间复杂度：O(n^2)（某些情况下）
   
10. 基数排序（Radix Sort）
    - 平均时间复杂度：O(d * (n + k))，其中 d 是数字的最大位数，k 是基数（例如十进制中的 10）
    - 最好时间复杂度：O(d * (n + k))
    - 最坏时间复杂度：O(d * (n + k))

请注意，这些时间复杂度是在不同排序算法的典型实现下的估计值。在实际应用中，算法的性能还受到实际数据分布和硬件环境等因素的影响。

------

### 二、基本数据结构

#### 1. 数据结构 - 数组

数组（Array）是一种数据结构，用于存储相同类型的元素的集合。数组提供了一种便捷的方式来访问和管理一系列元素，每个元素可以通过索引来唯一标识。索引通常从0开始，递增地表示元素在数组中的位置。

以下是有关数组的一些详细介绍：

**特点：**

- **同一类型元素：** 数组中的所有元素必须是相同类型，即具有相同的数据类型。
- **固定大小：** 数组的大小在创建时被确定，一旦分配了空间，通常不能动态改变数组的大小。这意味着数组的长度是固定的。

**优点：**

- **快速访问：** 数组中的元素可以通过索引直接访问，使得访问元素非常高效。
- **内存连续：** 数组中的元素在内存中是连续存储的，这有助于缓存性能的提升。

**缺点：**

- **固定大小：** 数组一旦被创建，大小就不能改变，如果需要动态地插入或删除元素，就需要额外的处理。
- **内存浪费：** 如果数组的大小远远超过了实际存储的元素数量，会造成内存的浪费。
- **不适合频繁插入和删除：** 在数组中插入或删除元素会涉及到元素的移动，这会导致性能较差。

当涉及到计算机编程中的数组，C++ 是一种常用的编程语言。数组是 C++ 中的一种基本数据结构，它可以存储一组相同数据类型的元素，并通过索引来访问这些元素。以下是一个详细介绍数组的示例，使用 C++ 编程语言。

```cpp
#include <iostream>

int main() {
    // 声明和初始化一个整数数组
    int intArray[5] = {10, 20, 30, 40, 50};

    // 访问数组元素
    std::cout << "第一个元素：" << intArray[0] << std::endl;  // 输出：第一个元素：10

    // 修改数组元素
    intArray[2] = 35;

    // 遍历数组并打印元素
    std::cout << "数组元素：";
    for (int i = 0; i < 5; ++i) {
        std::cout << intArray[i] << " ";
    }
    std::cout << std::endl;

    // 获取数组长度
    int length = sizeof(intArray) / sizeof(int);
    std::cout << "数组长度：" << length << std::endl;  // 输出：数组长度：5

    return 0;
}
```

在这个示例中，我们使用 C++ 创建了一个整数数组 `intArray`，并进行了一系列操作：

1. **声明和初始化：** 我们声明了一个名为 `intArray` 的整数数组，其大小为 5，然后用初始值进行初始化。
2. **访问数组元素：** 使用索引，我们可以访问数组中的元素。在 C++ 中，数组索引从0开始。
3. **修改数组元素：** 我们通过索引修改了数组的第3个元素，将其从 30 修改为 35。
4. **遍历数组：** 使用循环，我们遍历了整个数组，并打印了每个元素的值。
5. **获取数组长度：** 我们使用 `sizeof` 运算符来计算数组的总字节数，并除以单个元素的字节数，从而得到数组的长度。

总之，数组是 C++ 编程中非常基础和重要的数据结构，用于存储和操作一系列相同类型的数据。

------

#### 2. 数据结构 - 链表

链表（Linked List）是一种常见的线性数据结构，用于存储一系列元素。与数组不同，链表的元素在内存中不必是连续存储的，而是通过指针将它们链接在一起。链表的每个元素被称为节点（Node），每个节点包含了存储的数据以及一个指向下一个节点的指针。

以下是链表的一些关键特点和操作：

**特点：**
- **节点结构：** 每个链表节点通常包含两部分：数据和指向下一个节点的指针。
- **动态大小：** 链表的大小可以动态调整，不像数组需要预先分配固定大小的空间。
- **内存分散：** 链表的节点可以在内存中分散存储，不要求连续的内存块。
- **插入和删除：** 在链表中插入或删除节点相对容易，只需要调整指针的指向，而不需要移动其他节点。

**常见类型：**
1. **单链表（Singly Linked List）：** 每个节点包含数据和指向下一个节点的指针。
2. **双链表（Doubly Linked List）：** 每个节点包含数据、指向下一个节点的指针，以及指向前一个节点的指针。
3. **循环链表（Circular Linked List）：** 尾节点指向头节点，形成循环。

**优点：**
- 插入和删除操作相对容易，不需要移动大量元素。
- 动态分配内存，避免了数组大小固定的限制。

**缺点：**
- 需要额外的指针空间来维护节点关系，占用较多内存。
- 访问元素时需要从头节点开始遍历，访问速度相对较慢。

**示例（单链表）：**
```cpp
#include <iostream>

// 链表节点结构
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

int main() {
    // 创建链表节点
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);

    // 遍历链表并打印数据
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->data << " ";
        current = current->next;
    }
    std::cout << std::endl;

    // 清理内存
    current = head;
    while (current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
    }

    return 0;
}
```

上述示例展示了如何创建一个简单的单链表，遍历链表并打印节点的数据，最后释放分配的内存。链表是一种灵活的数据结构，用于解决动态大小和高效插入/删除操作的问题。

------

##### 2.1 单链表

单链表（Singly Linked List）是一种线性数据结构，用于存储一系列元素，每个元素被封装在一个节点中。每个节点包含两部分信息：存储的数据和指向下一个节点的指针。这个指针连接了链表中相邻节点，形成了链式的结构。

以下是单链表的一些关键特点和操作：

**特点：**
- **节点结构：** 每个节点通常包含两部分：数据和指向下一个节点的指针（通常称为 "next" 指针）。
- **动态大小：** 单链表的大小可以动态调整，不受固定大小的限制。
- **内存分散：** 单链表的节点可以在内存中分散存储，不要求连续的内存块。
- **插入和删除：** 在单链表中插入或删除节点相对容易，只需要调整指针的指向，而不需要移动其他节点。

**优点：**
- 插入和删除操作相对容易，不需要移动大量元素。
- 动态分配内存，避免了数组大小固定的限制。

**缺点：**
- 访问特定位置的元素需要从头节点开始遍历，访问速度较慢。
- 需要额外的指针空间来维护节点关系，占用较多内存。

**示例（单链表）：**
以下是一个简单的单链表示例，使用 C++ 编程语言。

```cpp
#include <iostream>

// 链表节点结构
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

int main() {
    // 创建链表节点
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);

    // 遍历链表并打印数据
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->data << " ";
        current = current->next;
    }
    std::cout << std::endl;

    // 清理内存
    current = head;
    while (current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
    }

    return 0;
}
```

上述示例展示了如何创建一个简单的单链表，遍历链表并打印节点的数据，最后释放分配的内存。在单链表中，每个节点只知道下一个节点的位置，这使得插入和删除操作变得相对容易，但访问特定位置的元素相对较慢。

------

##### 2.2 双链表

双链表（Doubly Linked List）是一种线性数据结构，类似于单链表，但每个节点有两个指针：一个指向前一个节点，一个指向后一个节点。这种双向链接的结构允许更方便地在链表中前后移动和操作元素。

以下是双链表的一些关键特点和操作：

**特点：**
- **节点结构：** 每个节点包含三部分信息：存储的数据、指向前一个节点的指针（通常称为 "prev" 指针）和指向后一个节点的指针（通常称为 "next" 指针）。
- **动态大小：** 双链表的大小可以动态调整，不受固定大小的限制。
- **内存分散：** 双链表的节点可以在内存中分散存储，不要求连续的内存块。
- **插入和删除：** 在双链表中插入或删除节点相对容易，只需要调整指针的指向，而不需要移动其他节点。

**优点：**
- 插入和删除操作相对容易，不需要移动大量元素。
- 支持双向遍历，访问前一个和后一个节点都很方便。

**缺点：**
- 需要额外的指针空间来维护节点关系，占用较多内存。

**示例（双链表）：**
以下是一个简单的双链列表示例，使用 C++ 编程语言。

```cpp
#include <iostream>

// 双链表节点结构
struct Node {
    int data;
    Node* prev;
    Node* next;
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

int main() {
    // 创建双链表节点
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);

    // 构建链表关系
    head->next = second;
    second->prev = head;
    second->next = third;
    third->prev = second;

    // 遍历双链表并打印数据
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->data << " ";
        current = current->next;
    }
    std::cout << std::endl;

    // 清理内存
    current = head;
    while (current != nullptr) {
        Node* temp = current;
        current = current->next;
        delete temp;
    }

    return 0;
}
```

上述示例展示了如何创建一个简单的双链表，设置节点之间的关系，遍历链表并打印节点的数据，最后释放分配的内存。双链表提供了双向遍历的便利性，但仍需要额外的指针空间来维护节点关系。

##### 2.3 循环链表

循环链表（Circular Linked List）是一种特殊类型的链表，与普通链表不同，它的最后一个节点指向第一个节点，形成一个循环。循环链表可以有单向循环和双向循环两种形式，具体取决于节点之间的指针关系。

以下是循环链表的一些关键特点和操作：

**特点：**
- **节点结构：** 类似于链表，循环链表的节点包含数据和指向下一个节点的指针。在双向循环链表中，还有一个指向前一个节点的指针。
- **循环性质：** 循环链表中的最后一个节点指向第一个节点，形成循环。
- **动态大小：** 循环链表的大小可以动态调整，不受固定大小的限制。
- **内存分散：** 循环链表的节点可以在内存中分散存储，不要求连续的内存块。
- **插入和删除：** 在循环链表中插入或删除节点相对容易，只需要调整指针的指向，而不需要移动其他节点。

**优点：**
- 插入和删除操作相对容易，不需要移动大量元素。
- 循环性质使得循环遍历非常方便，不需要考虑终止条件。

**示例（单向循环链表）：**
以下是一个简单的单向循环链表示例，使用 C++ 编程语言。

```cpp
#include <iostream>

// 循环链表节点结构
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

int main() {
    // 创建循环链表节点
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);

    // 构建循环链表关系
    head->next = second;
    second->next = third;
    third->next = head;

    // 遍历循环链表并打印数据
    Node* current = head;
    for (int i = 0; i < 10; ++i) {  // 循环遍历10次
        std::cout << current->data << " ";
        current = current->next;
    }
    std::cout << std::endl;

    // 清理内存
    Node* temp = head;
    do {
        Node* nextNode = temp->next;
        delete temp;
        temp = nextNode;
    } while (temp != head);

    return 0;
}
```

上述示例展示了如何创建一个简单的单向循环链表，设置节点之间的循环关系，遍历链表并打印节点的数据，最后释放分配的内存。循环链表的循环性质使得遍历更加方便。双向循环链表的创建和操作类似，只是节点间的指针关系更复杂一些。

------

###### 2.3.1 单向循环链表

单向循环链表（Singly Circular Linked List）是一种特殊类型的链表，它的最后一个节点指向第一个节点，形成一个循环。与普通链表不同，循环链表可以在任何节点开始遍历，而不仅仅是从头节点开始。这种循环性质使得循环链表在某些场景下非常有用。

以下是单向循环链表的一些关键特点和操作：

**特点：**
- **节点结构：** 每个节点包含数据和指向下一个节点的指针。最后一个节点的指针指向第一个节点，形成循环。
- **动态大小：** 循环链表的大小可以动态调整，不受固定大小的限制。
- **内存分散：** 循环链表的节点可以在内存中分散存储，不要求连续的内存块。
- **插入和删除：** 在循环链表中插入或删除节点相对容易，只需要调整指针的指向，而不需要移动其他节点。

**优点：**
- 插入和删除操作相对容易，不需要移动大量元素。
- 循环性质使得从任意节点开始遍历都很方便。

**示例（单向循环链表）：**
以下是一个简单的单向循环链列表示例，使用 C++ 编程语言。

```cpp
#include <iostream>

// 循环链表节点结构
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

int main() {
    // 创建循环链表节点
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);

    // 构建循环链表关系
    head->next = second;
    second->next = third;
    third->next = head;

    // 从任意节点开始遍历并打印数据
    Node* start = second;  // 从第二个节点开始遍历
    Node* current = start;
    for (int i = 0; i < 5; ++i) {  // 遍历5次
        std::cout << current->data << " ";
        current = current->next;
    }
    std::cout << std::endl;

    // 清理内存
    Node* temp = head;
    do {
        Node* nextNode = temp->next;
        delete temp;
        temp = nextNode;
    } while (temp != head);

    return 0;
}
```

上述示例展示了如何创建一个简单的单向循环链表，设置节点之间的循环关系，从任意节点开始遍历并打印节点的数据，最后释放分配的内存。单向循环链表的循环性质使得从不同位置开始遍历都很方便，同时还保持了链表的插入和删除的优势。

------

###### 2.3.2 双向循环链表

双向循环链表（Doubly Circular Linked List）是一种特殊类型的链表，与普通链表不同，它的最后一个节点同时指向第一个节点，形成一个循环。每个节点有两个指针，一个指向前一个节点，一个指向后一个节点，从而实现双向遍历和操作。

以下是双向循环链表的一些关键特点和操作：

**特点：**
- **节点结构：** 每个节点包含三部分信息：存储的数据、指向前一个节点的指针（"prev" 指针）和指向后一个节点的指针（"next" 指针）。最后一个节点的 "next" 指针指向第一个节点，第一个节点的 "prev" 指针指向最后一个节点，形成循环。
- **动态大小：** 双向循环链表的大小可以动态调整，不受固定大小的限制。
- **内存分散：** 双向循环链表的节点可以在内存中分散存储，不要求连续的内存块。
- **插入和删除：** 在双向循环链表中插入或删除节点相对容易，只需要调整指针的指向，而不需要移动其他节点。

**优点：**
- 插入和删除操作相对容易，不需要移动大量元素。
- 支持双向遍历，可以从前往后或从后往前遍历。

**示例（双向循环链表）：**
以下是一个简单的双向循环链列表示例，使用 C++ 编程语言。

```cpp
#include <iostream>

// 双向循环链表节点结构
struct Node {
    int data;
    Node* prev;
    Node* next;
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

int main() {
    // 创建双向循环链表节点
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);

    // 构建双向循环链表关系
    head->next = second;
    second->prev = head;
    second->next = third;
    third->prev = second;
    third->next = head;

    // 从前往后遍历并打印数据
    Node* currentForward = head;
    for (int i = 0; i < 5; ++i) {
        std::cout << currentForward->data << " ";
        currentForward = currentForward->next;
    }
    std::cout << std::endl;

    // 从后往前遍历并打印数据
    Node* currentBackward = third;
    for (int i = 0; i < 5; ++i) {
        std::cout << currentBackward->data << " ";
        currentBackward = currentBackward->prev;
    }
    std::cout << std::endl;

    // 清理内存
    Node* temp = head;
    do {
        Node* nextNode = temp->next;
        delete temp;
        temp = nextNode;
    } while (temp != head);

    return 0;
}
```

上述示例展示了如何创建一个简单的双向循环链表，设置节点之间的双向循环关系，从前往后和从后往前遍历并打印节点的数据，最后释放分配的内存。双向循环链表在需要双向遍历时非常有用，但仍然需要额外的指针空间来维护节点关系。

------

#### 3. 数据结构 - 栈

栈（Stack）是一种常见的线性数据结构，遵循后进先出（Last In First Out，LIFO）的原则。在栈中，最后放入的元素是第一个被移除的，而最早放入的元素是最后被移除的。栈通常用于管理函数的调用、表达式求值、撤销操作等场景。

栈的基本操作包括入栈（Push）和出栈（Pop）。入栈将元素放入栈的顶部，出栈将栈顶的元素移除。除了入栈和出栈，栈还具有以下特点和操作：

**特点：**
- **后进先出：** 最后放入栈的元素首先被移除。
- **固定大小：** 有些编程语言的栈是有固定大小的，一旦栈满了就无法再添加元素。但在许多编程语言中，栈的大小可以是动态的。
- **顶部操作：** 栈只能从栈顶进行插入和删除操作，不允许在中间插入或删除元素。
- **限制操作：** 有些栈可能限制特定的操作，如查看栈中的元素（Peek）或搜索元素。

**应用场景：**
- 函数调用：栈可以用来存储函数调用的返回地址和局部变量，从而实现函数的嵌套调用。
- 表达式求值：栈可以用来处理中缀表达式的转换和求值。
- 撤销操作：在编辑器或软件中，栈可以用于实现撤销操作。
- 括号匹配：栈可以用于检查表达式中的括号是否匹配。
- 浏览器前进/后退：浏览器的前进和后退操作可以通过栈来管理浏览历史。

**示例（C++ 栈）：**
以下是一个使用 C++ 标准库中的 `std::stack` 实现的简单栈示例。

```cpp
#include <iostream>
#include <stack>

int main() {
    // 创建一个整数栈
    std::stack<int> myStack;

    // 入栈操作
    myStack.push(10);
    myStack.push(20);
    myStack.push(30);

    // 出栈操作
    myStack.pop();  // 移除栈顶元素

    // 获取栈顶元素
    int topElement = myStack.top();  // 不会移除栈顶元素，只是获取其值
    std::cout << "栈顶元素：" << topElement << std::endl;

    // 检查栈是否为空
    if (myStack.empty()) {
        std::cout << "栈为空" << std::endl;
    } else {
        std::cout << "栈不为空，元素数量：" << myStack.size() << std::endl;
    }

    return 0;
}
```

上述示例演示了如何使用 C++ 标准库中的 `std::stack` 创建、操作和管理一个简单的整数栈。在实际编程中，栈常常是非常有用的工具，用于解决各种问题，包括函数调用、表达式求值和操作管理等。

------

#### 4. 数据结构 - 队列

队列（Queue）是一种常见的线性数据结构，遵循先进先出（First In First Out，FIFO）的原则。在队列中，最早加入的元素首先被移除，而最后加入的元素最后被移除。队列常用于模拟排队、任务调度等场景。

队列的基本操作包括入队（Enqueue）和出队（Dequeue）。入队将元素放入队列的尾部，出队将队列头部的元素移除。除了入队和出队，队列还具有以下特点和操作：

**特点：**
- **先进先出：** 最早放入队列的元素首先被移除。
- **固定大小：** 有些队列是有固定大小的，一旦队列满了就无法再添加元素。但在许多编程语言中，队列的大小可以是动态的。
- **队头和队尾操作：** 队列允许从队头删除元素（出队），从队尾添加元素（入队）。
- **限制操作：** 有些队列可能限制特定的操作，如查看队首元素（Front）或搜索元素。

**应用场景：**
- 任务调度：队列可以用于实现任务的按顺序执行。
- 缓冲区管理：队列可以用于缓冲区的管理，如生产者-消费者模型。
- 广度优先搜索：在图算法中，队列可以用于广度优先搜索（Breadth First Search，BFS）。
- 打印任务队列：在打印机管理中，打印任务可以按照先后顺序进入队列。
- 消息传递：在并发编程中，队列可以用于线程间的消息传递。

**示例（C++ 队列）：**
以下是一个使用 C++ 标准库中的 `std::queue` 实现的简单队列示例。

```cpp
#include <iostream>
#include <queue>

int main() {
    // 创建一个整数队列
    std::queue<int> myQueue;

    // 入队操作
    myQueue.push(10);
    myQueue.push(20);
    myQueue.push(30);

    // 出队操作
    myQueue.pop();  // 移除队首元素

    // 获取队首元素
    int frontElement = myQueue.front();  // 不会移除队首元素，只是获取其值
    std::cout << "队首元素：" << frontElement << std::endl;

    // 检查队列是否为空
    if (myQueue.empty()) {
        std::cout << "队列为空" << std::endl;
    } else {
        std::cout << "队列不为空，元素数量：" << myQueue.size() << std::endl;
    }

    return 0;
}
```

上述示例演示了如何使用 C++ 标准库中的 `std::queue` 创建、操作和管理一个简单的整数队列。队列在计算机科学中有广泛的应用，用于解决各种问题，包括任务调度、缓冲区管理、图算法等。

------

#### 5. 数据结构 - 哈希表

哈希表（Hash Table），也称为散列表，是一种用于存储键值对（key-value pairs）的数据结构。哈希表使用哈希函数将键映射到存储位置，从而快速地进行插入、查找和删除操作。哈希表的核心思想是将键转换为索引，从而在常数时间内访问数据。

以下是哈希表的一些关键特点和操作：

**特点：**
- **键值对存储：** 哈希表存储的是键值对，其中每个键是唯一的。
- **哈希函数：** 哈希表使用哈希函数将键映射到数组的索引。良好的哈希函数能够最大程度上减少冲突，即不同键映射到相同索引的情况。
- **冲突处理：** 由于哈希函数的映射可能导致不同键映射到相同索引，哈希表需要处理冲突。常见的冲突处理方法包括链地址法（Chaining）和开放地址法（Open Addressing）。
- **动态大小：** 哈希表的大小可以根据需求进行动态调整，以保持较低的负载因子，提高效率。

**优点：**
- 平均情况下，哈希表的插入、查找和删除操作的时间复杂度是常数级别的 O(1)。
- 适用于需要快速查找和存储的场景，如字典、缓存等。

**缺点：**
- 哈希函数的设计影响着哈希表的性能，不良的哈希函数可能导致冲突增多，影响操作效率。
- 哈希表的空间复杂度较高，因为需要分配足够大的数组来存储数据，尤其当负载因子较低时。

**应用场景：**
- 数据存储和快速查找：哈希表常用于实现字典、缓存、索引等数据结构，用于快速查找和存储数据。
- 数据去重：哈希表可以用于去除重复元素。
- 数据统计：通过哈希表可以快速统计各个元素的频率。
- 校验数据完整性：哈希表在密码学中也有应用，用于校验数据的完整性。

**示例（C++ 哈希表）：**
以下是一个使用 C++ 标准库中的 `std::unordered_map` 实现的简单哈希表示例。

```cpp
#include <iostream>
#include <unordered_map>

int main() {
    // 创建一个字符串到整数的哈希表
    std::unordered_map<std::string, int> myMap;

    // 插入键值对
    myMap["apple"] = 10;
    myMap["banana"] = 20;
    myMap["orange"] = 30;

    // 查找键对应的值
    std::string fruit = "banana";
    if (myMap.find(fruit) != myMap.end()) {
        std::cout << fruit << " 的值是：" << myMap[fruit] << std::endl;
    } else {
        std::cout << fruit << " 不存在于哈希表中" << std::endl;
    }

    // 删除键值对
    myMap.erase(fruit);

    return 0;
}
```

上述示例演示了如何使用 C++ 标准库中的 `std::unordered_map` 创建、操作和管理一个简单的字符串到整数的哈希表。在实际编程中，哈希表常常用于解决需要快速查找和存储的问题，如数据存储、去重、数据统计等。

------

### 三、排序和搜索算法

#### 1. 排序算法 - 冒泡排序

冒泡排序（Bubble Sort）是一种简单的排序算法，它通过多次比较和交换相邻元素来将一个序列按照升序或降序排列。在每一轮循环中，冒泡排序会比较相邻的两个元素，如果它们的顺序错误（比如前一个元素大于后一个元素），就会交换它们的位置。经过一轮循环后，最大（或最小）的元素会“冒泡”到序列的末尾。重复这个过程，直到整个序列有序。

以下是冒泡排序的基本思想和步骤：

**基本思想：**
- 从序列的开头开始，依次比较相邻的两个元素，如果它们的顺序错误，则交换它们。
- 通过多次比较和交换，将最大（或最小）的元素逐步“冒泡”到序列的末尾。
- 重复执行上述步骤，直到整个序列有序。

**步骤：**
1. 从序列的第一个元素开始，依次与下一个元素比较，如果当前元素大于下一个元素，则交换它们的位置。
2. 继续比较第二个和第三个元素，依次类推，直到最后两个元素。
3. 一轮比较结束后，最大的元素会“冒泡”到序列的末尾，此时最后一个位置已经排好序。
4. 重复上述步骤，每次忽略已经排好序的末尾元素，直到整个序列有序。

**时间复杂度：**
冒泡排序的时间复杂度取决于输入序列的初始状态，最好情况下是 O(n)，最坏情况下是 O(n^2)。空间复杂度为 O(1)，因为只需要常数级别的额外空间来进行元素交换。

**示例（C++ 冒泡排序）：**
以下是一个使用 C++ 实现的冒泡排序示例，按升序排列数组元素。

```cpp
#include <iostream>

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    bubbleSort(arr, n);

    std::cout << "排序后的数组：";
    for (int i = 0; i < n; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

上述示例演示了如何使用冒泡排序对一个整数数组进行升序排序。在实际应用中，冒泡排序不是最高效的排序算法，因为它的时间复杂度相对较高，但它是一个易于理解和实现的排序算法。

------

#### 2. 排序算法 - 选择排序

选择排序（Selection Sort）是一种简单的排序算法，它每次在未排序的部分中选择最小（或最大）的元素，并将其放到已排序的部分的末尾。选择排序的基本思想是通过不断地选择剩余部分中的最小（或最大）元素，将其放置到已排序部分的末尾，从而逐步构建有序序列。

以下是选择排序的基本思想和步骤：

**基本思想：**
- 在未排序的部分中，选择最小（或最大）的元素。
- 将选出的最小（或最大）元素与未排序部分的第一个元素交换位置。
- 重复上述步骤，每次将最小（或最大）元素放置到已排序部分的末尾。

**步骤：**
1. 在未排序的部分中，找到最小（或最大）的元素，记为 A。
2. 将 A 与未排序部分的第一个元素交换位置，将 A 放到已排序部分的末尾。
3. 在剩余未排序的部分中，重复上述步骤，每次将最小（或最大）元素放置到已排序部分的末尾。

**时间复杂度：**
选择排序的时间复杂度始终为 O(n^2)，不论输入序列的状态。虽然其时间复杂度较高，但在某些情况下（如小规模数据或部分已有序数据）可能仍然具有一定的效率。

**示例（C++ 选择排序）：**
以下是一个使用 C++ 实现的选择排序示例，按升序排列数组元素。

```cpp
#include <iostream>

void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 交换元素
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    selectionSort(arr, n);

    std::cout << "排序后的数组：";
    for (int i = 0; i < n; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

上述示例演示了如何使用选择排序对一个整数数组进行升序排序。选择排序的主要特点是每轮选择一个最小元素，并与已排序部分的末尾交换位置。与其他高效排序算法相比，选择排序通常性能较低，但在某些情况下可能仍然是一种可行的选择。

------

#### 3. 排序算法 - 插入排序

插入排序（Insertion Sort）是一种简单的排序算法，它将一个序列分为已排序和未排序两部分，逐步将未排序部分的元素插入到已排序部分中，从而构建有序序列。插入排序的基本思想类似于玩扑克牌时整理手中的牌，每次将一张牌插入到已经有序的牌中的合适位置。

以下是插入排序的基本思想和步骤：

**基本思想：**
- 将序列分为已排序部分和未排序部分。
- 从未排序部分中依次选择元素，插入到已排序部分的合适位置。
- 重复上述步骤，直到未排序部分为空。

**步骤：**
1. 将序列的第一个元素看作已排序部分。
2. 从未排序部分选择一个元素，将其插入到已排序部分的合适位置，使得已排序部分仍然保持有序。
3. 重复第2步，直到未排序部分为空。

**时间复杂度：**
插入排序的时间复杂度在最好情况下为 O(n)，在最坏情况下为 O(n^2)。虽然插入排序不是最高效的排序算法，但在处理部分已排序或小规模数据时具有一定的优势。

**示例（C++ 插入排序）：**
以下是一个使用 C++ 实现的插入排序示例，按升序排列数组元素。

```cpp
#include <iostream>

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; ++i) {
        int key = arr[i];  // 当前待插入元素
        int j = i - 1;

        // 从已排序部分寻找插入位置
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];  // 移动大于 key 的元素
            j--;
        }
        arr[j + 1] = key;  // 插入元素到正确位置
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    insertionSort(arr, n);

    std::cout << "排序后的数组：";
    for (int i = 0; i < n; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

上述示例演示了如何使用插入排序对一个整数数组进行升序排序。插入排序的主要特点是每次从未排序部分选择一个元素，插入到已排序部分的正确位置，从而逐步构建有序序列。插入排序在某些特定情况下可能是一种高效的选择，特别是对于部分已排序的数据。

------

#### 4. 排序算法 - 快速排序

快速排序（Quick Sort）是一种高效的排序算法，它采用分治策略将一个序列分为较小和较大的两个子序列，然后对这两个子序列递归地进行排序。快速排序的核心思想是选择一个基准元素，然后通过将序列中的元素重新排列，使得基准元素左边的元素都比它小，右边的元素都比它大，然后对左右两个子序列继续进行排序。

以下是快速排序的基本思想和步骤：

**基本思想：**
- 选择一个基准元素，将序列分为较小和较大的两个子序列。
- 对较小的子序列和较大的子序列递归地进行排序。
- 合并排好序的子序列，得到最终的有序序列。

**步骤：**
1. 选择一个基准元素，通常选择序列中的第一个元素。
2. 遍历序列，将比基准元素小的元素放到基准元素的左边，比基准元素大的元素放到右边。
3. 基准元素左边和右边分别形成两个子序列，对这两个子序列递归地进行快速排序。
4. 重复上述步骤，直到子序列的长度为1或0，即子序列已有序。

**时间复杂度：**
快速排序的平均时间复杂度为 O(n log n)，但在最坏情况下可能达到 O(n^2)。快速排序在实际应用中通常具有很高的效率，尤其在处理大规模数据时。

**示例（C++ 快速排序）：**
以下是一个使用 C++ 实现的快速排序示例，按升序排列数组元素。

```cpp
#include <iostream>

// 分区函数，将小于基准的元素放在左边，大于基准的元素放在右边
int partition(int arr[], int low, int high) {
    int pivot = arr[high];  // 选择最后一个元素作为基准
    int i = low - 1;  // i 表示小于基准的元素的最右边界

    for (int j = low; j <= high - 1; ++j) {
        if (arr[j] < pivot) {
            i++;
            // 交换元素
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    // 将基准元素放到正确的位置
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;

    return i + 1;
}

// 快速排序函数
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // 获取基准元素的正确位置
        int pivotIndex = partition(arr, low, high);

        // 递归地对左右两个子序列进行排序
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    quickSort(arr, 0, n - 1);

    std::cout << "排序后的数组：";
    for (int i = 0; i < n; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

上述示例演示了如何使用快速排序对一个整数数组进行升序排序。快速排序的主要特点是选择一个基准元素，将元素重新排列，使得基准元素的左边都小于它，右边都大于它，然后对左右两个子序列递归地进行排序。快速排序在实际应用中具有高效的性能表现，特别是对于大规模数据。

------

#### 5. 排序算法 - 归并排序

归并排序（Merge Sort）是一种分治算法，它将一个序列分为两个子序列，分别对两个子序列进行排序，然后将排好序的子序列合并成一个有序序列。归并排序的核心思想是将序列逐步分解为更小的子序列，然后合并这些子序列以构建最终的有序序列。

以下是归并排序的基本思想和步骤：

**基本思想：**
- 将序列分为两个子序列，分别对这两个子序列进行排序。
- 将排好序的两个子序列合并，得到最终的有序序列。

**步骤：**
1. 将序列分为两个相等或近似相等的子序列。
2. 递归地对这两个子序列进行排序，直到子序列的长度为1或0（基本情况）。
3. 合并两个排好序的子序列，得到一个有序序列。

**时间复杂度：**
归并排序的时间复杂度始终为 O(n log n)，不论输入序列的初始状态。归并排序在实际应用中性能稳定，适用于大规模数据的排序。

**示例（C++ 归并排序）：**
以下是一个使用 C++ 实现的归并排序示例，按升序排列数组元素。

```cpp
#include <iostream>

// 合并两个子序列
void merge(int arr[], int left, int middle, int right) {
    int n1 = middle - left + 1;
    int n2 = right - middle;

    // 创建临时数组存储两个子序列
    int L[n1], R[n2];
    for (int i = 0; i < n1; ++i) {
        L[i] = arr[left + i];
    }
    for (int j = 0; j < n2; ++j) {
        R[j] = arr[middle + 1 + j];
    }

    // 合并两个子序列到原始数组
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // 处理剩余的元素
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// 归并排序函数
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int middle = left + (right - left) / 2;

        // 递归地对左右两个子序列进行排序
        mergeSort(arr, left, middle);
        mergeSort(arr, middle + 1, right);

        // 合并两个子序列
        merge(arr, left, middle, right);
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    mergeSort(arr, 0, n - 1);

    std::cout << "排序后的数组：";
    for (int i = 0; i < n; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

上述示例演示了如何使用归并排序对一个整数数组进行升序排序。归并排序的主要特点是将序列分为两个子序列，分别对子序列进行排序，然后将排好序的子序列合并成一个有序序列。归并排序在实际应用中通常性能稳定，特别适用于大规模数据的排序。

------

#### 6. 排序算法 - 堆排序

堆排序（Heap Sort）是一种基于二叉堆（Binary Heap）的排序算法，它利用堆数据结构的特性来实现排序。堆是一种完全二叉树，分为最大堆和最小堆两种类型，其中最大堆满足父节点的值大于或等于其子节点的值，最小堆则相反。堆排序通过将序列构建成一个堆，然后依次取出堆顶元素，将其放置到有序序列中，再调整堆以保持堆的特性。

以下是堆排序的基本思想和步骤：

**基本思想：**

- 将序列构建成一个堆。
- 重复从堆中取出堆顶元素，将其放置到有序序列中，然后调整堆以保持堆的特性。

**步骤：**
1. 构建堆：将序列从底部开始调整，使其满足堆的特性。
2. 从堆中取出堆顶元素，即根节点，将其放置到有序序列的末尾。
3. 调整堆：将堆末尾的元素移到堆顶，然后依次与其子节点比较并交换，直到堆重新满足堆的特性。
4. 重复步骤2和步骤3，直到堆为空。

**时间复杂度：**
堆排序的平均和最坏时间复杂度均为 O(n log n)，并且是一种不稳定的排序算法。尽管堆排序的时间复杂度相对较高，但它适用于需要内部排序和不占用额外空间的情况。

**示例（C++ 堆排序）：**
以下是一个使用 C++ 实现的堆排序示例，按升序排列数组元素。

```cpp
#include <iostream>

// 调整堆，使其满足堆的特性
void heapify(int arr[], int n, int i) {
    int largest = i;  // 初始化父节点为最大值
    int left = 2 * i + 1;  // 左子节点索引
    int right = 2 * i + 2;  // 右子节点索引

    // 找到左、右子节点中的最大值
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    // 如果父节点不是最大值，则交换父节点与最大值节点
    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        // 递归地调整受影响的子树
        heapify(arr, n, largest);
    }
}

// 堆排序函数
void heapSort(int arr[], int n) {
    // 构建最大堆，从最后一个非叶节点开始调整
    for (int i = n / 2 - 1; i >= 0; --i) {
        heapify(arr, n, i);
    }

    // 从堆中取出元素，放入有序序列中
    for (int i = n - 1; i > 0; --i) {
        std::swap(arr[0], arr[i]);  // 将堆顶元素移到有序序列末尾
        heapify(arr, i, 0);  // 调整堆
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    heapSort(arr, n);

    std::cout << "排序后的数组：";
    for (int i = 0; i < n; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

上述示例演示了如何使用堆排序对一个整数数组进行升序排序。堆排序的主要特点是构建堆，然后将堆顶元素取出放置到有序序列中，再调整堆。堆排序在实际应用中适用于需要内部排序且不占用额外空间的情况。

------

#### 7. 搜索算法 - 线性搜索

线性搜索（Linear Search），也称为顺序搜索，是一种基本的搜索算法，用于在一个序列中查找特定的元素。线性搜索的基本思想是逐个检查序列中的元素，直到找到目标元素或遍历完整个序列。虽然线性搜索在大规模数据上可能不够高效，但在小规模数据或未排序数据中是一种简单而实用的搜索方法。

以下是线性搜索的基本步骤：

**步骤：**
1. 从序列的第一个元素开始，逐个检查每个元素。
2. 如果当前元素与目标元素相等，则找到了目标元素，搜索结束。
3. 如果已经遍历完整个序列但仍未找到目标元素，则搜索失败。

**时间复杂度：**
线性搜索的时间复杂度为 O(n)，其中 n 是序列的长度。在最坏情况下，线性搜索需要遍历整个序列才能找到目标元素。

**示例（C++ 线性搜索）：**
以下是一个使用 C++ 实现的线性搜索示例，用于在整数数组中查找特定的目标元素。

```cpp
#include <iostream>

// 线性搜索函数
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; ++i) {
        if (arr[i] == target) {
            return i;  // 找到目标元素，返回索引
        }
    }
    return -1;  // 未找到目标元素，返回 -1
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 22;

    int result = linearSearch(arr, n, target);

    if (result != -1) {
        std::cout << "目标元素 " << target << " 在数组中的索引为：" << result << std::endl;
    } else {
        std::cout << "未找到目标元素 " << target << "。" << std::endl;
    }

    return 0;
}
```

上述示例演示了如何使用线性搜索在一个整数数组中查找特定的目标元素。线性搜索逐个检查数组元素，直到找到目标元素或遍历整个数组。在实际应用中，线性搜索适用于小规模数据或未排序数据，但对于大规模数据或需要高效搜索的情况，可能需要考虑更高效的搜索算法。

------

#### 8. 搜索算法 - 二分搜索

二分搜索（Binary Search），也称为折半搜索，是一种高效的搜索算法，用于在有序序列中查找特定的元素。二分搜索的基本思想是将有序序列分成两部分，然后比较目标元素与序列的中间元素，根据比较结果缩小搜索范围。如果目标元素等于中间元素，则找到目标元素；否则，根据比较结果，继续在左半部分或右半部分进行二分搜索。

以下是二分搜索的基本步骤：

**步骤：**
1. 确定搜索范围的左边界和右边界，初始时整个序列即为搜索范围。
2. 计算搜索范围的中间位置，找到中间元素。
3. 比较目标元素与中间元素的大小。
   - 如果目标元素等于中间元素，则找到目标元素，搜索结束。
   - 如果目标元素小于中间元素，则在左半部分继续进行二分搜索。
   - 如果目标元素大于中间元素，则在右半部分继续进行二分搜索。
4. 重复步骤2和步骤3，直到找到目标元素或搜索范围为空。

**时间复杂度：**
二分搜索的时间复杂度为 O(log n)，其中 n 是序列的长度。由于每次搜索都将搜索范围缩小一半，因此二分搜索在有序序列中非常高效。

**示例（C++ 二分搜索）：**
以下是一个使用 C++ 实现的二分搜索示例，用于在升序排列的整数数组中查找特定的目标元素。

```cpp
#include <iostream>

// 二分搜索函数
int binarySearch(int arr[], int left, int right, int target) {
    while (left <= right) {
        int middle = left + (right - left) / 2;

        if (arr[middle] == target) {
            return middle;  // 找到目标元素，返回索引
        } else if (arr[middle] < target) {
            left = middle + 1;  // 在右半部分继续搜索
        } else {
            right = middle - 1;  // 在左半部分继续搜索
        }
    }
    return -1;  // 未找到目标元素，返回 -1
}

int main() {
    int arr[] = {11, 12, 22, 25, 34, 64, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 22;

    int result = binarySearch(arr, 0, n - 1, target);

    if (result != -1) {
        std::cout << "目标元素 " << target << " 在数组中的索引为：" << result << std::endl;
    } else {
        std::cout << "未找到目标元素 " << target << "。" << std::endl;
    }

    return 0;
}
```

上述示例演示了如何使用二分搜索在一个升序排列的整数数组中查找特定的目标元素。二分搜索在每次比较后都将搜索范围缩小一半，因此在有序序列中非常高效。在实际应用中，如果数据是有序的并且要求高效搜索，二分搜索是一个非常好的选择。

------

### 四、递归与分治

#### 1. 递归的示例

当函数调用自身的过程称为递归。递归是一种强大的编程技术，它常常用于解决问题，特别是那些可以分解为相同类型的子问题的问题。以下是一个递归示例，展示了如何使用递归来计算阶乘。

**阶乘（Factorial）：**
阶乘是一个正整数 n 的乘积，记作 n!。它的定义为：n! = n * (n-1) * (n-2) * ... * 1。例如，5! = 5 * 4 * 3 * 2 * 1 = 120。

**递归计算阶乘（C++ 示例）：**
以下是一个使用 C++ 实现的递归示例，计算给定正整数的阶乘。

```cpp
#include <iostream>

// 递归计算阶乘函数
int factorial(int n) {
    if (n <= 1) {
        return 1;  // 基本情况：0! 和 1! 都为 1
    } else {
        return n * factorial(n - 1);  // 递归调用
    }
}

int main() {
    int num = 5;
    int result = factorial(num);

    std::cout << num << " 的阶乘为 " << result << std::endl;

    return 0;
}
```

上述示例展示了如何使用递归来计算给定正整数的阶乘。递归函数 `factorial` 在每次递归调用时，将问题分解为更小的相同类型的子问题，直到达到基本情况（0! 和 1! 都为 1），然后逐层返回结果。递归在解决某些问题时非常有用，但需要注意递归深度和效率的问题。

------

#### 2. 分治的示例

分治是一种算法设计策略，它将问题分解成更小的子问题，然后将子问题的解合并成原问题的解。以下是一个分治示例，展示了如何使用分治策略来求解一个数组中的最大子数组和，该问题也被称为最大子数组问题。

**最大子数组和问题：**
给定一个整数数组，要求找到其中连续子数组的和最大值。

**分治解决最大子数组和问题（C++ 示例）：**
以下是一个使用 C++ 实现的分治示例，用于求解给定整数数组的最大子数组和。

```cpp
#include <iostream>
#include <climits>

// 求解跨越中点的最大子数组和
int maxCrossingSum(int arr[], int low, int middle, int high) {
    int leftSum = INT_MIN;  // 左半部分的最大子数组和
    int rightSum = INT_MIN;  // 右半部分的最大子数组和
    int sum = 0;

    // 从中点开始向左计算最大子数组和
    for (int i = middle; i >= low; --i) {
        sum += arr[i];
        if (sum > leftSum) {
            leftSum = sum;
        }
    }

    sum = 0;

    // 从中点的下一个位置开始向右计算最大子数组和
    for (int i = middle + 1; i <= high; ++i) {
        sum += arr[i];
        if (sum > rightSum) {
            rightSum = sum;
        }
    }

    // 返回跨越中点的最大子数组和
    return leftSum + rightSum;
}

// 分治求解最大子数组和问题
int maxSubarraySum(int arr[], int low, int high) {
    if (low == high) {
        return arr[low];  // 基本情况：数组中只有一个元素
    }

    int middle = (low + high) / 2;

    // 分别求解左半部分、右半部分、跨越中点的最大子数组和
    int leftMax = maxSubarraySum(arr, low, middle);
    int rightMax = maxSubarraySum(arr, middle + 1, high);
    int crossMax = maxCrossingSum(arr, low, middle, high);

    // 返回左半部分、右半部分、跨越中点三者中的最大值
    return std::max(std::max(leftMax, rightMax), crossMax);
}

int main() {
    int arr[] = {-2, -3, 4, -1, -2, 1, 5, -3};
    int n = sizeof(arr) / sizeof(arr[0]);

    int result = maxSubarraySum(arr, 0, n - 1);

    std::cout << "数组的最大子数组和为 " << result << std::endl;

    return 0;
}
```

上述示例演示了如何使用分治策略解决最大子数组和问题。分治算法将问题分解成更小的子问题，分别求解左半部分、右半部分和跨越中点的最大子数组和，然后将这三者中的最大值作为最终结果返回。分治在解决一些问题时非常有效，但也需要注意分治深度和效率的问题。

------

### 五、动态规划

#### 1. 背包问题

动态规划是一种常用于解决优化问题的算法设计方法，背包问题就是其中一个经典的例子。背包问题可以分为 0-1 背包问题和完全背包问题，它们在选择物品放入背包时存在不同的限制条件。

##### 1.1 0-1 背包问题
给定一组物品，每个物品有重量和价值，以及一个固定的背包容量。目标是选择物品放入背包，使得所选物品的总重量不超过背包容量，且总价值最大。

以下是使用动态规划解决 0-1 背包问题的基本步骤：

1. 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示在前 `i` 个物品中，背包容量为 `j` 时的最大价值。
2. 初始化第一行和第一列，即当物品数量为 0 或背包容量为 0 时，最大价值均为 0。
3. 对于每个物品 `i`，遍历背包容量从 0 到背包容量 `C`，计算 `dp[i][j]` 的值：
   - 如果物品 `i` 的重量大于当前背包容量 `j`，则无法将物品 `i` 放入背包，所以 `dp[i][j] = dp[i-1][j]`。
   - 否则，可以选择将物品 `i` 放入背包或不放入背包，取二者中的最大值：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])`。
4. 最终结果为 `dp[n][C]`，其中 `n` 是物品数量，`C` 是背包容量。

下面是一个使用动态规划解决 0-1 背包问题的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int knapsack(int capacity, const std::vector<int>& weights, const std::vector<int>& values) {
    int n = weights.size();  // 物品数量
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(capacity + 1, 0));

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= capacity; ++j) {
            if (weights[i - 1] > j) {
                // 当前物品重量大于背包容量，无法放入背包，保持上一个状态
                dp[i][j] = dp[i - 1][j];
            } else {
                // 可以选择将当前物品放入背包或不放入背包，取较大值
                dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);
            }
        }
    }

    return dp[n][capacity];  // 返回最大价值
}

int main() {
    int capacity = 7;  // 背包容量
    std::vector<int> weights = {1, 3, 4, 5};  // 物品重量
    std::vector<int> values = {1, 4, 5, 7};   // 物品价值

    int max_value = knapsack(capacity, weights, values);

    std::cout << "背包问题的最大价值为: " << max_value << std::endl;

    return 0;
}
```

上述示例演示了如何使用动态规划解决 0-1 背包问题。动态规划在解决背包问题时，通过填表格的方式逐步计算每个子问题的最优解，最终得到整个问题的最优解。这是一个高效且经典的优化问题求解方法。

------

##### 1.2 完全背包问题

完全背包问题与 0-1 背包问题类似，但不同之处在于每个物品可以选择无限次放入背包，而不是仅一次。以下是使用动态规划解决完全背包问题的基本步骤：

**步骤：**
1. 创建一个一维数组 `dp`，其中 `dp[j]` 表示背包容量为 `j` 时的最大价值。
2. 初始化 `dp` 数组，即当背包容量为 0 时，最大价值为 0。
3. 对于每个物品 `i`，遍历背包容量从 0 到背包容量 `C`，计算 `dp[j]` 的值：
   - 如果物品 `i` 的重量大于当前背包容量 `j`，则无法将物品 `i` 放入背包，所以 `dp[j]` 不变。
   - 否则，可以选择将物品 `i` 放入背包或不放入背包，取二者中的最大值：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`。
4. 最终结果为 `dp[C]`，其中 `C` 是背包容量。

下面是一个使用动态规划解决完全背包问题的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int knapsack(int capacity, const std::vector<int>& weights, const std::vector<int>& values) {
    int n = weights.size();  // 物品数量
    std::vector<int> dp(capacity + 1, 0);  // 动态规划数组，存储每个背包容量对应的最大价值

    for (int i = 0; i < n; ++i) {
        for (int j = weights[i]; j <= capacity; ++j) {
            // 计算在当前背包容量下的最大价值，可以选择放入当前物品或不放
            dp[j] = std::max(dp[j], dp[j - weights[i]] + values[i]);
        }
    }

    return dp[capacity];  // 返回最大价值
}

int main() {
    int capacity = 7;  // 背包容量
    std::vector<int> weights = {1, 3, 4, 5};  // 物品重量
    std::vector<int> values = {1, 4, 5, 7};   // 物品价值

    int max_value = knapsack(capacity, weights, values);

    std::cout << "完全背包问题的最大价值为: " << max_value << std::endl;

    return 0;
}
```

上述示例演示了如何使用动态规划解决完全背包问题。完全背包问题与 0-1 背包问题相似，但在状态转移方程上有所不同，因为每个物品可以选择多次放入背包。动态规划仍然通过填表格的方式计算每个子问题的最优解，最终得到整个问题的最优解。这是一种在优化问题中广泛使用的算法。

------

##### 1.3 多重背包问题

多重背包问题是背包问题的一种变体，它与完全背包问题和 0-1 背包问题类似，但不同之处在于每种物品有多个可用数量，需要在限制背包容量的情况下，选择适当数量的物品以最大化总价值。

以下是使用动态规划解决多重背包问题的基本步骤：

**步骤：**
1. 创建一个一维数组 `dp`，其中 `dp[j]` 表示背包容量为 `j` 时的最大价值。
2. 初始化 `dp` 数组，即当背包容量为 0 时，最大价值为 0。
3. 对于每种物品 `i`，遍历背包容量从 `weights[i]` 到背包容量 `C`，计算 `dp[j]` 的值：
   - 如果物品 `i` 的重量大于当前背包容量 `j`，则无法放入背包，保持上一个状态。
   - 否则，遍历可用的物品数量，选择将 0 到 `k * weights[i]` 个物品 `i` 放入背包，其中 `k` 是可用的物品数量。
   - 更新 `dp[j]` 为不同物品数量情况下的最大值。
4. 最终结果为 `dp[C]`，其中 `C` 是背包容量。

下面是一个使用动态规划解决多重背包问题的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int knapsack(int capacity, const std::vector<int>& weights, const std::vector<int>& values, const std::vector<int>& quantities) {
    int n = weights.size();  // 物品数量
    std::vector<int> dp(capacity + 1, 0);  // 动态规划数组，存储每个背包容量对应的最大价值

    for (int i = 0; i < n; ++i) {
        for (int j = capacity; j >= weights[i]; --j) {
            for (int k = 1; k <= quantities[i] && k * weights[i] <= j; ++k) {
                dp[j] = std::max(dp[j], dp[j - k * weights[i]] + k * values[i]);
            }
        }
    }

    return dp[capacity];  // 返回最大价值
}

int main() {
    int capacity = 7;  // 背包容量
    std::vector<int> weights = {1, 3, 4, 5};  // 物品重量
    std::vector<int> values = {1, 4, 5, 7};   // 物品价值
    std::vector<int> quantities = {2, 3, 1, 4};  // 物品可用数量

    int max_value = knapsack(capacity, weights, values, quantities);

    std::cout << "多重背包问题的最大价值为: " << max_value << std::endl;

    return 0;
}
```

上述示例演示了如何使用动态规划解决多重背包问题。在动态规划过程中，通过填表格的方式逐步计算每个背包容量对应的最大价值，考虑了每种物品可用数量的限制。这个问题是背包问题中的一个扩展，适用于有多个相同物品可供选择的情况。

------

#### 2. 最长公共子序列（Longest Common Subsequence，LCS）问题

最长公共子序列（Longest Common Subsequence，LCS）问题是一个经典的动态规划问题，涉及两个序列（通常是字符串）的比较，要求找到它们的最长公共子序列的长度。

以下是使用动态规划解决最长公共子序列问题的基本步骤：

**步骤：**
1. 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示序列 A 的前 `i` 个元素与序列 B 的前 `j` 个元素的最长公共子序列的长度。
2. 初始化第一行和第一列，即当一个序列为空时，最长公共子序列的长度为 0。
3. 对于每个元素 `A[i]` 和 `B[j]`，如果它们相等，那么最长公共子序列的长度在此基础上加 1，即 `dp[i][j] = dp[i-1][j-1] + 1`。
4. 如果 `A[i]` 和 `B[j]` 不相等，那么最长公共子序列的长度取 `dp[i-1][j]` 和 `dp[i][j-1]` 中的较大值。
5. 最终结果为 `dp[m][n]`，其中 `m` 和 `n` 分别是序列 A 和序列 B 的长度。

下面是一个使用动态规划解决最长公共子序列问题的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int longestCommonSubsequence(const std::string& text1, const std::string& text2) {
    int m = text1.length();
    int n = text2.length();
    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1, 0));

    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[m][n];  // 返回最长公共子序列的长度
}

int main() {
    std::string text1 = "abcde";
    std::string text2 = "ace";

    int lcs_length = longestCommonSubsequence(text1, text2);

    std::cout << "最长公共子序列的长度为: " << lcs_length << std::endl;

    return 0;
}
```

上述示例演示了如何使用动态规划解决最长公共子序列问题。动态规划通过填表格的方式逐步计算每个子问题的最优解，最终得到整个问题的最优解。最长公共子序列问题是动态规划中的一个典型应用。

------

#### 3. 最长递增子序列（Longest Increasing Subsequence，LIS）问题

最长递增子序列（Longest Increasing Subsequence，LIS）问题是另一个常见的动态规划问题，它要求找到给定序列中的最长递增子序列的长度。

以下是使用动态规划解决最长递增子序列问题的基本步骤：

**步骤：**
1. 创建一个一维数组 `dp`，其中 `dp[i]` 表示以第 `i` 个元素结尾的最长递增子序列的长度。
2. 初始化 `dp` 数组，将每个元素的最长递增子序列长度初始化为 1，因为任何单个元素本身都是一个递增子序列。
3. 对于每个元素 `arr[i]`，遍历所有在 `i` 之前的元素 `arr[j]`（`j < i`），如果 `arr[i]` 大于 `arr[j]`，则更新 `dp[i]` 为 `max(dp[i], dp[j] + 1)`。
4. 最终结果为 `dp` 数组中的最大值。

下面是一个使用动态规划解决最长递增子序列问题的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int longestIncreasingSubsequence(const std::vector<int>& nums) {
    int n = nums.size();
    std::vector<int> dp(n, 1);

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                dp[i] = std::max(dp[i], dp[j] + 1);
            }
        }
    }

    return *std::max_element(dp.begin(), dp.end());  // 返回最长递增子序列的长度
}

int main() {
    std::vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};

    int lis_length = longestIncreasingSubsequence(nums);

    std::cout << "最长递增子序列的长度为: " << lis_length << std::endl;

    return 0;
}
```

上述示例演示了如何使用动态规划解决最长递增子序列问题。通过填表格的方式逐步计算每个子问题的最优解，最终得到整个问题的最优解。最长递增子序列问题是动态规划中的一个重要问题，也有其他优化算法可以用来解决。

------

#### 4. 硬币找零问题

硬币找零问题是一个经典的动态规划问题，它涉及使用不同面额的硬币来凑出特定的金额，要求找到所需的最少硬币数量。

以下是使用动态规划解决硬币找零问题的基本步骤：

**步骤：**
1. 创建一个一维数组 `dp`，其中 `dp[i]` 表示凑出金额 `i` 所需的最少硬币数量。
2. 初始化 `dp` 数组，将所有位置的值初始化为一个较大的数，除了 `dp[0]` 为 0（金额为 0 时，不需要硬币）。
3. 对于每个硬币面额 `coin`，遍历从 `coin` 到目标金额 `amount`，更新 `dp[j]` 为 `min(dp[j], dp[j - coin] + 1)`，即当前金额所需硬币数量为前一个金额所需硬币数量加上当前硬币的一枚。
4. 最终结果为 `dp[amount]`，即凑出目标金额所需的最少硬币数量。

下面是一个使用动态规划解决硬币找零问题的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int coinChange(const std::vector<int>& coins, int amount) {
    std::vector<int> dp(amount + 1, INT_MAX);
    dp[0] = 0;

    for (int coin : coins) {
        for (int i = coin; i <= amount; ++i) {
            if (dp[i - coin] != INT_MAX) {
                dp[i] = std::min(dp[i], dp[i - coin] + 1);
            }
        }
    }

    return (dp[amount] == INT_MAX) ? -1 : dp[amount];  // 返回最少硬币数量
}

int main() {
    std::vector<int> coins = {1, 2, 5};
    int amount = 11;

    int min_coins = coinChange(coins, amount);

    std::cout << "凑出金额 " << amount << " 需要的最少硬币数量为: " << min_coins << std::endl;

    return 0;
}
```

上述示例演示了如何使用动态规划解决硬币找零问题。通过填表格的方式逐步计算每个子问题的最优解，最终得到问题的最优解。硬币找零问题是一个常见的动态规划问题，它可以用于实际生活中的货币找零场景。

------

### 六、贪心算法

#### 1. 零钱兑换问题

贪心算法可以用来解决一部分零钱兑换问题，特别是当硬币面额之间存在倍数关系时。贪心算法的基本思想是每次选择局部最优解，然后希望最终能得到全局最优解。在零钱兑换问题中，如果硬币面额之间是某个面额的倍数关系，贪心算法可能会得到正确的最优解。

以下是一个使用贪心算法解决零钱兑换问题的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int coinChangeGreedy(const std::vector<int>& coins, int amount) {
    std::sort(coins.begin(), coins.end(), std::greater<int>());  // 将硬币面额从大到小排序
    int count = 0;

    for (int coin : coins) {
        while (amount >= coin) {
            amount -= coin;
            count++;
        }
    }

    return (amount == 0) ? count : -1;  // 如果 amount 为 0，返回硬币数量，否则返回 -1 表示无法凑出 amount
}

int main() {
    std::vector<int> coins = {1, 2, 5};
    int amount = 11;

    int min_coins = coinChangeGreedy(coins, amount);

    std::cout << "凑出金额 " << amount << " 需要的最少硬币数量为: " << min_coins << std::endl;

    return 0;
}
```

上述示例中，贪心算法通过每次选择面额最大的硬币来找零，如果金额能够被该硬币减去，则将硬币数量加一。在硬币面额是倍数关系的情况下，这种贪心策略通常是有效的。然而，在硬币面额不满足倍数关系的情况下，贪心算法可能无法得到最优解。

需要注意的是，贪心算法解决零钱兑换问题并不总是适用，因为在一些情况下，贪心选择可能会导致错误的结果。在一般情况下，使用动态规划算法能够得到可靠的最优解。

------

#### 2. 活动选择问题

贪心算法可以成功地解决活动选择问题，这是一个经典的贪心应用问题。活动选择问题是在一组互相竞争的活动中选择一些活动，使得它们不会相互冲突，同时能够选择尽可能多的活动。每个活动都有一个开始时间和结束时间。

以下是使用贪心算法解决活动选择问题的基本思路：

**步骤：**
1. 对所有活动按照结束时间进行排序，确保结束时间早的活动排在前面。
2. 选择第一个活动，将它加入已选活动集合。
3. 从剩余的活动中选择下一个满足不冲突条件的活动，即该活动的开始时间要晚于或等于已选活动的结束时间。
4. 重复步骤 3，直到所有活动都被考虑完毕。

贪心算法在每一步都选择满足条件的局部最优解，最终会得到全局的最优解。活动选择问题满足贪心选择性质，即每次选择结束时间最早的活动，可以证明这种策略是最优的。

下面是一个使用贪心算法解决活动选择问题的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Activity {
    int start;
    int finish;
};

bool compareActivities(const Activity& a, const Activity& b) {
    return a.finish < b.finish;
}

void printMaxActivities(const std::vector<Activity>& activities) {
    int n = activities.size();
    std::sort(activities.begin(), activities.end(), compareActivities);

    std::cout << "选择的活动为：" << std::endl;

    int i = 0;
    std::cout << "(" << activities[i].start << ", " << activities[i].finish << ") ";

    for (int j = 1; j < n; ++j) {
        if (activities[j].start >= activities[i].finish) {
            std::cout << "(" << activities[j].start << ", " << activities[j].finish << ") ";
            i = j;
        }
    }
}

int main() {
    std::vector<Activity> activities = {
        {1, 4}, {3, 5}, {0, 6}, {5, 7}, {3, 9}, {5, 9},
        {6, 10}, {8, 11}, {8, 12}, {2, 14}, {12, 16}
    };

    printMaxActivities(activities);

    return 0;
}
```

在上述示例中，通过贪心算法选择活动，确保每次都选择结束时间最早的活动。这种策略可以保证最终选择的活动集合是相互兼容且数量最多的。

------

#### 3. 分糖果问题

分糖果问题是一个经典的贪心算法应用问题，通常被用来描述如何在一组孩子中分发糖果，以满足特定的条件，例如让相邻孩子的糖果数量满足一定的关系。

以下是使用贪心算法解决分糖果问题的基本思路：

**步骤：**
1. 创建两个数组，一个用来存储孩子的糖果分配情况，另一个用来存储孩子之间的关系（比如当前孩子的评分与前一个孩子的评分的关系）。
2. 首先，给每个孩子分配一个初始糖果，然后从左到右遍历一遍，如果当前孩子的评分大于前一个孩子，就让其糖果数量加一，以确保评分高的孩子得到更多的糖果。
3. 接着，从右到左遍历一遍，如果当前孩子的评分大于后一个孩子，同时当前孩子的糖果数量不大于后一个孩子的糖果数量加一，就让其糖果数量加一，以保证评分高且在右侧的孩子得到更多的糖果。
4. 最终，糖果数组中的每个位置所对应的数字即为该位置孩子分配的糖果数量。

下面是一个使用贪心算法解决分糖果问题的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>

int candyDistribution(const std::vector<int>& ratings) {
    int n = ratings.size();
    std::vector<int> candies(n, 1);

    for (int i = 1; i < n; ++i) {
        if (ratings[i] > ratings[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }

    for (int i = n - 2; i >= 0; --i) {
        if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {
            candies[i] = candies[i + 1] + 1;
        }
    }

    int totalCandies = 0;
    for (int candy : candies) {
        totalCandies += candy;
    }

    return totalCandies;
}

int main() {
    std::vector<int> ratings = {1, 0, 2};

    int totalCandies = candyDistribution(ratings);

    std::cout << "分发的总糖果数量为: " << totalCandies << std::endl;

    return 0;
}
```

在上述示例中，我们通过贪心算法，根据孩子的评分分配糖果，保证评分高的孩子得到更多的糖果，并且满足相邻孩子的糖果数量关系。这种策略能够得到满足条件的最小糖果分发数量。

------

### 七、图算法

#### 1. 深度优先搜索

深度优先搜索（Depth-First Search，DFS）是一种用于图和树遍历的算法。它通过从起始节点开始，尽可能深入地访问节点，直到无法继续深入为止，然后回溯并探索其他未访问的路径。

DFS 使用递归或显式的栈数据结构来实现。在执行 DFS 时，算法将会沿着一条路径尽可能深入，直到到达叶节点或无法继续前进的节点。然后，算法会回溯到上一个分支点，并继续探索其他分支。

DFS 通常用于解决图的遍历、路径搜索、连通性判断等问题。在树结构中，DFS 可以用来查找树的深度、判断树的平衡性等。

以下是一个使用递归实现的深度优先搜索的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>

class Graph {
public:
    Graph(int vertices);
    void addEdge(int u, int v);
    void DFS(int start);

private:
    int vertices;
    std::vector<std::unordered_set<int>> adjList;
    void DFSUtil(int vertex, std::unordered_set<int>& visited);
};

Graph::Graph(int vertices) {
    this->vertices = vertices;
    adjList.resize(vertices);
}

void Graph::addEdge(int u, int v) {
    adjList[u].insert(v);
    adjList[v].insert(u);
}

void Graph::DFSUtil(int vertex, std::unordered_set<int>& visited) {
    visited.insert(vertex);
    std::cout << vertex << " ";

    for (int neighbor : adjList[vertex]) {
        if (visited.find(neighbor) == visited.end()) {
            DFSUtil(neighbor, visited);
        }
    }
}

void Graph::DFS(int start) {
    std::unordered_set<int> visited;
    DFSUtil(start, visited);
}

int main() {
    Graph g(5);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);

    std::cout << "深度优先遍历结果：";
    g.DFS(2);

    return 0;
}
```

上述示例中，我们创建了一个简单的图类 `Graph`，使用邻接表存储图的结构。通过递归的方式实现了深度优先搜索算法。在给定起始节点后，算法会从起始节点开始深度优先遍历整个图，并输出遍历的顺序。

------

#### 2. 广度优先搜索

广度优先搜索（Breadth-First Search，BFS）是一种用于图和树遍历的算法。它从起始节点开始，逐层地向外扩展，先访问当前节点的所有邻居节点，然后再依次访问这些邻居节点的邻居节点，依此类推。

BFS 使用队列数据结构来实现。在执行 BFS 时，算法会从起始节点开始，将其加入队列，并将其标记为已访问。然后，算法会依次从队列中取出节点，并将其邻居节点加入队列，直到队列为空为止。

BFS 通常用于解决图的遍历、路径搜索、最短路径查找等问题。在树结构中，BFS 可以用来查找树的层级、广度等。

以下是一个使用队列实现的广度优先搜索的示例（C++ 实现）：

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>

class Graph {
public:
    Graph(int vertices);
    void addEdge(int u, int v);
    void BFS(int start);

private:
    int vertices;
    std::vector<std::unordered_set<int>> adjList;
};

Graph::Graph(int vertices) {
    this->vertices = vertices;
    adjList.resize(vertices);
}

void Graph::addEdge(int u, int v) {
    adjList[u].insert(v);
    adjList[v].insert(u);
}

void Graph::BFS(int start) {
    std::vector<bool> visited(vertices, false);
    std::queue<int> q;

    q.push(start);
    visited[start] = true;

    std::cout << "广度优先遍历结果：";

    while (!q.empty()) {
        int vertex = q.front();
        q.pop();
        std::cout << vertex << " ";

        for (int neighbor : adjList[vertex]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}

int main() {
    Graph g(5);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);

    g.BFS(2);

    return 0;
}
```

在上述示例中，我们创建了一个图类 `Graph`，使用邻接表存储图的结构。通过队列的方式实现了广度优先搜索算法。在给定起始节点后，算法会从起始节点开始广度优先遍历整个图，并输出遍历的顺序。

------

